title: "除算・平方根の計算のためのハードウェアアルゴリズム"
date: 2021/06/30 00:00:01
postid: b
tag:
  - アルゴリズム
  - Ruby
category:
  - Programming
thumbnail: /images/20210630b/thumbnail.gif
author: 松本耕太朗
featured: true
lede: "CPUには除算や平方根といった比較的複雑な計算が必要な演算を行うハードウェアが実装されています。除算は、筆算に対応するような単純な方法で計算すると、ビット数nとしてOの計算ステップ（≒CPUサイクル数）がかかります。しかしながら、50年以上前から、これらをより高速に計算するアルゴリズムが開発され、ハードウェア上で実装されています。"
mathjax: true
---
[アルゴリズムとデータ構造](/articles/20210628a/)連載の3日目です。

# 除算・平方根の計算のためのハードウェアアルゴリズム

CPUには除算や平方根といった比較的複雑な計算が必要な演算を行うハードウェアが実装されています。除算は、筆算に対応するような単純な方法で計算すると、ビット数nとしてO(n)の計算ステップ（≒CPUサイクル数）がかかります。

しかしながら、50年以上前から、これらをより高速に計算するアルゴリズムが開発され、ハードウェア上で実装されています。

教科書にも載るくらい代表的なものとしてニュートン・ラフソン法（以下、ニュートン法）を利用するものがあります。本ページではこれを解説してみます。

# ニュートン法による除算計算アルゴリズム

ニュートン法により除算の計算結果の近似値を反復的に求め続けることで、計算結果に必要なだけの精度で除算結果が得られます。

# ニュートン法とは

ニュートン法は数値計算のアルゴリズムの一種で、実数値関数 f に関して $f(x) = 0$ となる $x$ を求めるものです。

<div class="iframely-embed"><div class="iframely-responsive" style="height: 140px; padding-bottom: 0;"><a href="https://ja.wikipedia.org/wiki/%E3%83%8B%E3%83%A5%E3%83%BC%E3%83%88%E3%83%B3%E6%B3%95" data-iframely-url="//cdn.iframe.ly/OMrdcBd"></a></div></div><script async src="//cdn.iframe.ly/embed.js" charset="utf-8"></script>

https://ja.wikipedia.org/wiki/ニュートン法

初期値を $x_0$ とし、近似値を $x_n$ として、以下の漸化式で次の近似値 $x_{n+1}$ を求めます。

$$
x_{n+1} = x_n - \frac{f(x_n) }{ f'(x_n)}
$$

グラフで幾何的に考えると、 $x = x_n$ と $f(x)$ との交点から接線を引いて、その接線がx軸に交わる点を次の近似値とする、という意味合いになります。

図で表現すると以下です。

<img src="/images/20210630b/Slide02.gif" alt="ニュートン方" height="800" width="600" loading="lazy">

※ http://www.akita-pu.ac.jp/system/elect/ins/kusakari/japanese/teaching/Old/Programming/2005/note/6/Slide02.html より引用

# 計算結果の誤差

一般的に、ニュートン法による近似値と真値との誤差は、前計算ステップの誤差の二分の一になること（二次収束すること）を示すことができます。

すなわち、誤差は計算ステップに対して指数的に減少(!)し、数値の二進展開における正しい桁数の長さが、計算ステップごとに倍になっていきます。

よくある $\sqrt 2$ の例を計算してみました。

$$
\begin{align}
\\\\
真値 \\\\
x_\infty & = 1.4142135623730950488016887242096980785696718753769480731766797379... \\\\
\\\\
計算値 \\\\
x_0 & = 2.0　(初期値) \\\\
x_1 & = \underline{1.}5 \\\\
x_2 & = \underline{1.41}6666666666666666666666667 \\\\
x_3 & = \underline{1.41421}56862745098039215686274515570934256055363321 \\\\
x_4 & = \underline{1.41421356237}46899106262955788901349109826621075447 \\\\
x_5 & = \underline{1.41421356237309504880168}96235025302436149819257771 \\\\
x_6 & = \underline{1.41421356237309504880168872420969807856967187537}72 \\\\
\\\\
\end{align}
$$

# 除算への適用

除数 $D$ に対して $f(x) = 1/x - D$ とおいて、ニュートン法により $D$ の逆数 $1/D$ を数値的に求めます。

このとき漸化式は

$$
x_{n+1} = x_i ( 2 - D x_i )
$$

となります。

ビット数 $n$ として最下位ビットまで正確に計算するのに必要な計算ステップ数は $O( \log n)$ となります。

# 平方根への計算

開平対象の値を $N$ に対して $f(x) = x^2 - N$ とおいて、ニュートン法により $ \sqrt N$ を数値的に求めます。

このとき漸化式は

$$
x_{n+1} = \frac{1}{2} \Biggr( x_n + \frac {N}{x_n} \Biggl)
$$

となります。


# 参考： 開平を計算するコード（ruby)

実装例として入力に $N$ を与えると、ニュートン法により $\sqrt N$ をRubyで計算します。

```ruby
require 'bigdecimal'
N,_=gets.chomp.split(' ').map{|n| n.to_i}

x = BigDecimal(N)
# sqrt N
puts x
for i in 0..5
	x = x - (x**2 - N) / (2 * x)
	puts x
end
```

# まとめ

* CPUの演算器の実装としてハードウェアアルゴリズムがはるか昔から研究されている
* ニュートン法による除算や開平のアルゴリズムが有名
* ニュートン法は二次収束するため計算ステップに対して指数的に誤差が減少する
